修饰符：private 对类进行封装。
	getter、setter方法
封装:把数据和方法包装进类中，以及具体实现的隐藏
final关键字：修饰类、方法、属性、变量
super关键字：代表父类对象
多态：
	1、引用多态：父类引用指向本类对象，父类引用指向子类对象。
	2、方法多态：调用父类方法，调用子类中重写的方法或者继承父类的方法。
引用类型转换：
	1、向上类型转换（自动类型转换）是小类型到大类型的转换。
	2、向下类型转换（强制类型转换）是大类型到小类型的转换。
	3、instanceof运算符
抽象类：
	abstract定义抽象类，过父类的引用来指向子类的实例来间接地实现父类的实例化（接口压根就没有构造函数）。
	虽然抽象类不能被实例化，但可以有构造函数。由于抽象类的构造函数在实例化派生类之前发生，所以，可以在这个阶段初始化抽象类字段或执行其它与子类相关的代码。
接口使用:
	接口的引用指向实现类的对象。
	与匿名内部类使用
	接口的所有方法都是抽象的，而抽象方法是没有static，有static的方法是不能override的，不能实现多态
static：  声明为static的方法有以下几条限制： 
	・ 它们仅能调用其他的static 方法。 
	・ 它们只能访问static数据。 
	・ 它们不能以任何方式引用this 或super。
静态成员被类的所有对象共享，同过对象访问非静态方法
java异常：
	try
	{
	 // 程序代码
	}catch(ExceptionName e1)
	{
 	  //Catch 块
	}
无论是否发生异常，finally 代码块中的代码总会被执行
	try{
	  // 程序代码
	}catch(异常类型1 异常的变量名1){
	  // 程序代码
	}catch(异常类型2 异常的变量名2){
	  // 程序代码
	}finally{
 	 // 程序代码
	}	
map：
	Map提供了一种映射关系，其中的元素是以键值对（key-value）的形式存储的，能够实现根据key快速查找value；
	Map中的键值对以Entry类型的对象实例形式存在；
	建（key值）不可重复，value值可以重复，一个value值可以和很多key值形成对应关系，每个建最多只能映射到一个值。
	Map支持泛型，形式如：Map<K,V>
	Map中使用put(K key,V value)方法添加
hashmap：
	HashMap是Map的一个重要实现类，也是最常用的，基于哈希表实现
	HashMap中的Entry对象是无序排列的
	Key值和value值都可以为null，但是一个HashMap只能有一个key值为null的映射（key值不可重复）
	hashmap是没有顺序的，而treemap则是按顺序排列






